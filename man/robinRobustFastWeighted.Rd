% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ROBINWeighted.R
\name{robinRobustFastWeighted}
\alias{robinRobustFastWeighted}
\title{#' rewireComplWeight
#'
#' @description rewires the weighted graph, creates the communities and
#' compares the communities through different measures.
#'
#' @param data The output of prepGraph.
#' @param number Number of rewiring trials to perform.
#' @param community Community to compare with.
#' @param method The clustering method, one of "walktrap", "edgeBetweenness",
#' "fastGreedy", "louvain", "spinglass","leadingEigen", "labelProp", "infomap",
#' "optimal","leiden", "other".
#' @param FUN see \code{\link{methodCommunity}}.
#' @param measure The measure for the comparison of the communities "vi", "nmi",
#' "split.join", "adjusted.rand".
#' @param weights this argument is not settable for "infomap" method.
#' @param steps this argument is settable only for "leadingEigen"and"walktrap"
#' method.
#' @param spins This argument is settable only for "infomap" method.
#' @param e.weights This argument is settable only for "infomap" method.
#' @param v.weights This argument is settable only for "infomap" method.
#' @param nb.trials This argument is settable only for "infomap" method.
#' @param directed This argument is settable only for "edgeBetweenness" method
#' @param objective_function Whether to use the Constant Potts Model (CPM) or 
#' modularity. Must be either "CPM" or "modularity".
#' @param n_iterations the number of iterations to iterate the Leiden algorithm. 
#' Each iteration may improve the partition further.This argument is settable 
#' only for "leiden".
#' @param resolution only for "louvain" and "leiden". Optional resolution
#'  parameter, lower values typically yield fewer, larger clusters (default=1).
#' @param dist Option to rewire in a manner that retains overall graph weight 
#' regardless of distribution of edge weights. This option is invoked by putting 
#' any text into this field. Defaults to "NegBinom" for negative binomial.
#' @keywords internal
#'
rewireComplWeight <- function(data, number, community,
                              method=c("walktrap", "edgeBetweenness",
                                       "fastGreedy", "louvain", "spinglass",
                                       "leadingEigen", "labelProp", "infomap",
                                       "optimal","leiden", "other"),
                              FUN=NULL,
                              measure= c("vi", "nmi","split.join", "adjusted.rand"),
                              dist="NegBinom",
                              ...)
                              # directed=FALSE, weights=NULL, steps=4, spins=25,
                              # e.weights=NULL, v.weights=NULL, nb.trials=10, 
                              # resolution=1, n_iterations=2,
                              # objective_function = c("CPM", "modularity"),
                              # )
{
    method <- match.arg(method)
    measure <- match.arg (measure)
    adj <- as_adjacency_matrix(data, attr="weight", sparse = FALSE)
    graphRewire <- as.matrix(perturbR::rewireR(adj, number,dist=dist))
    graphRewire <- graph_from_adjacency_matrix(graphRewire, weighted=TRUE, mode="undirected")
    args <- c(list(graph=graphRewire), method=method, FUN=FUN, ...)
    comR <- do.call(membershipCommunities, args)
    # comR <- membershipCommunities(graph=graphRewire, method=method, FUN=FUN,
    #                               directed=directed, weights=weights, steps=steps,
    #                               spins=spins, e.weights=e.weights,
    #                               v.weights=v.weights, nb.trials=nb.trials,
    #                               resolution=resolution,
    #                               objective_function = objective_function,
    #                               n_iterations=n_iterations)
    Measure <- igraph::compare(community, comR, method=measure)
    output <- list(Measure=Measure, graphRewire=graphRewire)
    
    return(output)
}
robinRobustFastWeighted}
\usage{
robinRobustFastWeighted(
  graph,
  graphRandom,
  method = c("walktrap", "edgeBetweenness", "fastGreedy", "louvain", "spinglass",
    "leadingEigen", "labelProp", "infomap", "optimal", "leiden", "other"),
  ...,
  FUN1 = NULL,
  measure = c("vi", "nmi", "split.join", "adjusted.rand"),
  verbose = TRUE,
  dist = "NegBinom",
  BPPARAM = BiocParallel::bpparam()
)
}
\arguments{
\item{graph}{The output of prepGraph.}

\item{graphRandom}{The output of random function.}

\item{method}{The clustering method, one of "walktrap", "edgeBetweenness",
"fastGreedy", "louvain", "spinglass", "leadingEigen", "labelProp", "infomap",
"leiden","optimal".}

\item{measure}{The stability measure, one of "vi", "nmi", "split.join",
"adjusted.rand" all normalized and used as distances.
"nmi" refers to 1- nmi and "adjusted.ran" refers to 1-adjusted.rand.}

\item{verbose}{flag for verbose output (default as TRUE).}

\item{dist}{Option to rewire in a manner that retains overall graph weight 
regardless of distribution of edge weights. This option is invoked by putting 
any text into this field. Defaults to "NegBinom" for negative binomial.}

\item{BPPARAM}{the BiocParallel object of class \code{bpparamClass} that 
specifies the back-end to be used for computations. See
  \code{\link[BiocParallel]{bpparam}} for details.}

\item{FUN}{in case the @method parameter is "other" there is the possibility
to use a personal function passing its name through this parameter.
The personal parameter has to take as input the @graph and the @weights
(that can be NULL), and has to return a community object.}

\item{weights}{this argument is not settable for "infomap" method.}

\item{steps}{this argument is settable only for "leadingEigen"and"walktrap"
method.}

\item{spins}{This argument is settable only for "infomap" method.}

\item{e.weights}{This argument is settable only for "infomap" method.}

\item{v.weights}{This argument is settable only for "infomap" method.}

\item{nb.trials}{This argument is settable only for "infomap" method.}

\item{directed}{This argument is settable only for "edgeBetweenness" method.}

\item{objective_function}{Whether to use the Constant Potts Model (CPM) or 
modularity. Must be either "CPM" or "modularity".}

\item{n_iterations}{the number of iterations to iterate the Leiden algorithm. 
Each iteration may improve the partition further.This argument is settable 
only for "leiden".}

\item{resolution}{only for "louvain" and "leiden". Optional resolution 
parameter, lower values typically yield fewer, larger clusters (default=1).}
}
\value{
A list object with two matrices:
- the matrix "Mean" with the means of the procedure for the graph
- the matrix "MeanRandom" with the means of the procedure for the random graph.
}
\description{
This functions implements a procedure to examine the stability
of the partition recovered by some algorithm against random perturbations
of the original graph structure for weighted network.
}
\keyword{internal}
