---
title: "Vignette"
author: "Valeria Policastro"
date: "27 marzo 2019"
output:
  html_document: default
  pdf_document: default
  word_document: default
---
#Abstract
In network analysis, many community detection algorithms have been developed. 
However,their applications leave unaddressed one important question: 
the statistical validation of the results. 
Are the detected communities significant or are they a result of chance only 
due to the positions of edges in the network?

ROBIN (Robustness In Network)gives a statistical answer to the validation of 
the community structure by looking at the robustness of the network.

The package implements a methodology that detects if the community structure 
found by a detection algorithm is statistically significant or is a result 
of chance, merely due to edge positions in the network. It performs a 
perturbation strategy and runs a null model to build a set of procedures based 
on the Variation of Information as a clustering distance. 

In particular, it provides:
1)A procedure to examine the stability of the partition recovered against random 
perturbations of the original graph structure
2)Three tests to determine whether the obtained clustering departs significantly 
from the null model
3)A routine to compare different detection algorithms applied to the same 
network to discover which fits better
4)A graphical interactive representation 

### Install packages
```{r}

```


# Preparation of the Graph 
As input, the ROBIN package expects a network that can be read from different 
format: edgelist, pajek, graphml, gml, ncol, lgl, dimacs, graphdb and igraph 
graphs.

With the prepGraph command we will create from the input file the graph needed 
for the Robin procedure.
```{r}
my_file <- "Dati/data/football.gml" 
#downloaded from: http://www-personal.umich.edu/~mejn/netdata/
graph <- prepGraph(file=my_file,file.format="gml")
graph
```

# Random Graph 
So we will create the Random graph (null model) that has to be used for the 
package, the graph argument must be the output of the prepGraph function.
```{r}
graphRandom <- random(graph=graph) 
```

# Plot graph
To have a plot of the network 
```{r}
plotGraph (graph)
```

# Create Community 
To create the communities, in the package are implemented all the igraph 
algorithms. 
```{r}
methodCommunity (graph=graph, method="fastGreedy") #as community 
membershipCommunities(graph=graph, method="fastGreedy") #as membership
```

#Community Plot
It gives an interactive 3D plot of the communites for the algorithm chosen
```{r}
plotCommu(graph=graph, method="fastGreedy") 
```

# Procedure to validate the robustness
It creates the Robin procedure to validate the robustness of your network.
To make things easier we will save the output lists in Proc because we will need 
them after.
```{r}
Proc<- robinProc(graph=graph,graphRandom=graphRandom, method="louvain",
                 type="independent")
```

# Robin Plots
We will create a Plot to compare the curves obtained from the Procedure.
Plotting the average of the VI measure versus the percentuage of perturbation
of the real data and the null model.
The model argument must be the viMean output of the robinProc function and
the modelR argument must be the viMeanRandom output of the robinProc function.
```{r}
plotRobin(graph= graph, model=Proc$viMean,modelR=Proc$viMeanRandom)
```

# Statistical Tests Real data Null model 
We will then test the differeces between this two curves with:
-Functional data analysis
-Gaussian Process
-AUC
The argument of model1 must be the viMean output of the function robinProc and 
the argument of model2 must be the viMeanRandom output of the function 
robinProc.
```{r}
robinFDATest(graph=graph, model1=Proc$viMean,model2=Proc$viMeanRandom)

robinGPTest(ratio=Proc$ratios)

robinAUCTest(graph=graph,model1=Proc$viMean,model2=Proc$viMeanRandom)
```
# Comparison Two different Methods
Now we want yo see if we have two different algoritms which of them is the best?
Taking for example the Fast Greedy and the Louvain algorithm, we want to check 
which of this two algorithms fits better our network.
We will firstly plot them with their different communities to have an idea of 
the network of interest.
```{r}
plotCommu(graph=graph, method="fastGreedy")
plotCommu(graph=graph, method="louvain")
```
Secondly we will run the comparison function to calculate the comparison Robin 
procedure that is different from the previous one, but as before we will save 
the output in a name Comp, because we will use it later.
```{r}
Comp <- comparison(graph=graph, graphRandom=graphRandom, method1="fastGreedy",
                method2="louvain",type="independent")
```
Thirdly we will plot the curves of the null model and the real data for both
methods and the two curves of the two methods in comparison.
The model1 argument must be the viMean1 output of the comparison function, the 
modelR1 argument must be the viMeanRandom1,the model2 argument must be the 
viMean2 and the modelR2 argument must be the viMeanRandom2 all outputs of the
comparison function.
```{r}
plotRobinCompare(graph=graph, model1=Comp$viMean1, model2=Comp$viMean2,
                 modelR1=Comp$viMeanRandom1, modelR2=Comp$viMeanRandom2,
                 legend=c("real data", "null model"),
                 legend1vs2=c("Fast Greedy","Louvain"),
                 title1="Fast Greedy",title2="Louvain",
                 title1vs2="Fast Greedy vs Louvain")
```

# Statistical Tests between two methods 
We will then test them as we did it before but for the comparison the model1 
argument must be the viMean1 output of the function comparison and the model2 
argument must be the viMean2 output of the function comparison.
```{r}
robinFDATest(graph=graph, model1=Comp$viMean1, model2=Comp$viMean2)

robinGPTest(ratio=Comp$ratios1vs2)

robinAUCTest(graph=graph, model1=Comp$viMean1, model2=Comp$viMean2)

```

