---
title: "robin"
subtitle: "ROBustness In Network"
author: "Valeria Policastro"
date: "`r Sys.Date()`"
vignette: >
  %\VignetteIndexEntry{robin}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
output:
  knitr:::html_vignette:
    toc: yes
    toc_depth: 2
---


# robin

In network analysis, many community detection algorithms have been developed. 
However,their applications leave unaddressed one important question: 
**the statistical validation of the results**. 


*robin* (ROBustness in Network) has a double aim: **tests the robustness** of a community detection algorithm to  detects if the community structure found is statistically significant and **compares two detection algorithms** to choose the one that better fits the network of interest.

Reference in Policastro V., Righelli D., Carissimo A., Cutillo L., De Feis I. (2021) <https://journal.r-project.org/archive/2021/RJ-2021-040/index.html>.


It provides:
**1)** a procedure to examine the robustness of a community detection algorithm against random 
perturbations of the original graph; 
**2)** two tests to determine the statistical difference between stability measure curves;
**3)** a routine to choose among different community detection algorithms the one that better fits the network of interest;
**4)** a graphical interactive representation.

# Installation
```{r}
#install.packages("robin")
```

If there are problems with the installation try:
```{r}
# if (!requireNamespace("BiocManager", quietly = TRUE))
#     install.packages("BiocManager")
# BiocManager::install("gprege")
# 
# install.packages("robin")
```

# Loading package
```{r message=FALSE, warning=FALSE, paged.print=TRUE}
library("robin")
```

# Input 

**prepGraph** function creates an *igraph* object from the input file. This step is necessary for *robin* execution

The *unweighted*  graph can be read from different 
format: edgelist, pajek, graphml, gml, ncol, lgl, dimacs, graphdb and igraph 
graphs.

```{r}
my_network <- system.file("example/football.gml", package="robin")
# downloaded from: http://www-personal.umich.edu/~mejn/netdata/
graph <- prepGraph(file=my_network, file.format="gml")
graph
```


# Network visualization
**plotGraph** function offers a graphical representation of the network with the aid of *networkD3* package.

```{r}
plotGraph(graph)
```

## Community detection 
**methodCommunity** function detects communities using all the algorithms implemented in *igraph* package:  "walktrap", "edgeBetweenness", "fastGreedy", "spinglass", "leadingEigen",
"labelProp", "infomap", "optimal", "other".

```{r}
methodCommunity(graph=graph, method="fastGreedy") 
```
**membershipCommunities** function detects the community membership.
```{r}
membershipCommunities(graph=graph, method="fastGreedy") 
```

## Community visualization

**plotComm** function produces an interactive 3D plot of the communites detected by the chosen algorithm.

```{r}
members <- membershipCommunities(graph=graph, method="fastGreedy")
plotComm(graph=graph, members=members)
```

# Robustness of a community detection algorithm

## Null model 

*robin* offers two choices for the null model:

1) it can be generated by using the function **random**

2) it can be built externally and passed directly to the argument *graphRandom* of the **robinRobust** function.


The function **random** creates a random graph with the same degree distribution of the
original graph, but with completely random edges. The *graph* argument must be the same returned by **prepGraph** function. 

```{r}
graphRandom <- random(graph=graph)
graphRandom
```


**robinRobust** function implements the validation of the community robustness.
In this example we used "vi" distance as stability measure, "indipendent" 
type procedure and "louvain" as community detection algorithm. 

Users can choose also different measures as: "nmi","split.join", "adjusted.rand".

The *graph* argument must be the one returned by **prepGraph** function.
The *graphRandom* must be the one returned by **random** function.

```{r}
proc <- robinRobust(graph=graph, graphRandom=graphRandom, measure="vi", 
                  method="louvain", type="independent")
```
As output **robinRobust** will give all the measures at different level of perturbation from 0% to 60%.


**plotRobin** function plots the curves. 
The (x,y)-axes represents the percentage of perturbation and the average of the stability measure, respectively.
The arguments of *model1* and *model2* must be the measures for the real graph and the random graph that are the outputs of the **robinRobust** function.


*We will expect that with a robust algorithm the behavior of the two curves is different.We expect that the curve of the real graph vary less than the curve of the random graph, this visually means that the curve of the real graph is lower than the one of the random graph, so it is more stable than a random graph.*  

```{r}
plotRobin(graph=graph, model1=proc$Mean, model2=proc$MeanRandom, measure="vi",
legend=c("real data", "null model"))
```
The procedure implemented depends on the network of interest. In this example, the Louvain algorithm fits good the network of interest,as the curve of the stability measure assumes lower values than the one obtained by the null model. 
  

  
## Statistical tests
The differences between the stability measure curves are tested using:
1) Functional Data Analysis (FDA);
2) Gaussian Process (GP).
Moreover to quantify the differences between the curves when they are
very close the Area Under the Curves (AUC) are evaluated.


**robinFDATest** function implements the FDA testing giving a p-value for different intervals of the curves. It tests where the curve of the real graph and of the random graph are different.

```{r}
robinFDATest(graph=graph, model1=proc$Mean, model2=proc$MeanRandom, 
             measure="vi",legend=c("real graph", "random graph"))
```

The first figure represents the stability measure plot using Louvain algorithm for detecting communities. The second one represents the corresponding adjusted p-values of the Interval Testing procedure. Horizontal red line corresponds to the critical value 0.05. 

**robinGPTest** function implements the GP testing.
```{r message=FALSE, warning=FALSE}
robinGPTest(model1=proc$Mean, model2=proc$MeanRandom)
```
The output is the Bayes Factor.

**robinAUC** function implements the AUC.

```{r}
robinAUC(graph=graph, model1=proc$Mean, model2=proc$MeanRandom, 
             measure="vi")
```
The outputs are the area under the two curves


# Comparison of two community detection algorithms

**robinCompare** function compares two detection algorithms on the same network  and permits the user
to choose the one that better fits the network of interest.

In this example we consider the "Fast Greedy" and "Louvain" algorithms.

We firstly plot the communities dectected by both algorithms.

```{r}
membersFast <- membershipCommunities(graph=graph, method="fastGreedy")
membersLouv <- membershipCommunities(graph=graph, method="louvain")
plotComm(graph=graph, members=membersFast)
plotComm(graph=graph, members=membersLouv)
```

Secondly, we compare them with **robinCompare** function. 


```{r}
comp <- robinCompare(graph=graph, method1="fastGreedy",
                method2="louvain", measure="vi", type="independent")
```

Thirdly, we plot the curves of the compared methods.


```{r}
plotRobin(graph=graph, model1=comp$Mean1, model2=comp$Mean2, measure="vi", 
legend=c("fastGreedy", "louvain"), title="FastGreedy vs Louvain")
```

In this example, the Louvain algorithm fits better the network of interest, 
as the curve of the stability measure assumes lower values than the one obtained by 
the Fast greedy method. 

## Statistical tests

The following procedures test the statistical differences between the two curves using two different methods
```{r}
robinFDATest(graph=graph, model1=comp$Mean1, model2=comp$Mean2, measure="vi")

```

```{r message=FALSE, warning=FALSE}
robinGPTest(model1=comp$Mean1, model2=comp$Mean2)
```

while 
```{r}
robinAUC(graph=graph, model1=comp$Mean1, model2=comp$Mean2, measure="vi")
```
calculates the area under the curves.
