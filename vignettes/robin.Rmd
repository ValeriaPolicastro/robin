---
title: "robin"
subtitle: "ROBustness In Network"
author: "Valeria Policastro - Dario Righelli"
date: "`r Sys.Date()`"
vignette: >
  %\VignetteIndexEntry{robin}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
output:
  knitr:::html_vignette:
    toc: yes
    toc_depth: 2
---


# ROBIN

In network analysis, many community detection algorithms have been developed. 
However,their applications leave unaddressed one important question: 
**the statistical validation of the results**. 


ROBIN (ROBustness In Network) is an R package for the validation of community 
detection it has a double aim: it **studies the robustness** of a community 
detection algorithm and **compares** the robustness of **different community detection algorithms** on the same network. 

It provides:
1)A procedure to examine the robustness of a community detection algorithm against random 
perturbations of the original graph
2)Two tests to determine the statistical difference between stability measure curves
3)A routine to choose among different community detection algorithms the one that better fits the network of interest
4)A graphical interactive representation 

# Install package
```{r message=FALSE, warning=FALSE, paged.print=TRUE}
library("robin")
```

# Preparation of the Graph 
As input, the **ROBIN** package expects a network that can be read from different 
format: edgelist, pajek, graphml, gml, ncol, lgl, dimacs, graphdb and igraph 
graphs.

**prepGraph** function creates an *igraph* object from the input file. This step is necessary for ROBIN execution

```{r}
my_network <- system.file("example/football.gml", package="robin")
# downloaded from: http://www-personal.umich.edu/~mejn/netdata/
graph <- prepGraph(file=my_network, file.format="gml")
graph
```

# Random Graph 
**random** creates the null model for the robustness procedure **robinRobust**. The graph argument must be the same returned by **prepGraph** function.

```{r}
graphRandom <- random(graph=graph)
graphRandom
```

# Plot graph
**plotGraph** function implements a graphical representation of the network with aid of *networkD3* package.

```{r}
plotGraph(graph)
```

# Create Community 
To dectect communities using all the algorithms implemented in *igraph* package.

```{r}
methodCommunity(graph=graph, method="fastGreedy") #as community 
membershipCommunities(graph=graph, method="fastGreedy") #as membership
```

# Community Plot

**plotComm** produces an interactive 3D plot of the communites detected by chosen algorithm.

```{r}
members <- membershipCommunities(graph=graph, method="fastGreedy")
plotComm(graph=graph, members=members)
```

# Procedure to validate the robustness
**robinRobust** implements the validation of community robustness.
In this example we use "vi" distance as stability measure, indipendent 
type procedure and *louvain* as community detection algorithm. 
Users can choose different measures ("nmi","split.join", "adjusted.rand") and 
algorithms (walktrap", "edgeBetweenness", "fastGreedy", "spinglass", "leadingEigen",
"labelProp", "infomap", "optimal", "other").

```{r}
proc <- robinRobust(graph=graph, graphRandom=graphRandom, measure="vi", 
                  method="louvain", type="independent")
```

# Robin Plots
**plotRobin** function plots the stability measure curves. 
The (x,y)-axis represent the percentuage of perturbation and the average of the stability measure, respectively.

```{r}
plotRobin(graph=graph, model1=proc$Mean, model2=proc$MeanRandom, 
legend=c("real data", "null model"), measure="vi")
```

# Statistical Tests between Real data and Null model 
The differeces between this two curves are tested using:
- Functional data analysis
- Gaussian Process
- Area Under the Curve (AUC)


```{r}
robinFDATest(graph=graph, model1=proc$Mean, model2=proc$MeanRandom, 
             measure="vi")
```

The first figure represents the stability measure plot on the clustering obtained via *louvain* algorithm. The second one represents the corresponding adjusted p-values of the Interval Testing procedure. Horizontal red line corresponds to the critical value 0.05. 

```{r}
robinGPTest(ratio=proc$ratios)
```
The output is the Bayes Factor

```{r}
robinAUC(graph=graph, model1=proc$Mean, model2=proc$MeanRandom, 
             measure="vi")
```
The outputs are the area under the two curves


# Comparison Two different Methods

To choose among different community detection algorithms the one that better fits the network of interest, the fuction **robinCompare** has to be used.

In this example we take the *Fast Greedy* and *Louvain* algorithms.

We firstly plot the communities dectected by both algorithms.

```{r}
membersFast <- membershipCommunities(graph=graph, method="fastGreedy")
membersLouv <- membershipCommunities(graph=graph, method="louvain")
plotComm(graph=graph, members=membersFast)
plotComm(graph=graph, members=membersLouv)
```

Secondly, we compare the with **robinCompare** function. 


```{r}
comp <- robinCompare(graph=graph, method1="fastGreedy",
                method2="louvain", measure="vi", type="independent")
```

Thirdly, we plot the two curves of the two compared methods.


```{r}
plotRobin(graph=graph, model1=comp$Mean1, model2=comp$Mean2, measure="vi", 
legend=c("fastGreedy", "louvain"), title="FastGreedy vs Louvain")
```

In this example, the Louvain algorithm fits better the network of interest, 
as the curve of the stability measure assumes lower values than the one obtained by 
the Fast greedy method. 

# Statistical Tests between two community detection algorithms

The following procedures test the statistical differeces between the two curves using two different methods
```{r}
robinFDATest(graph=graph, model1=comp$Mean1, model2=comp$Mean2, measure="vi")
robinGPTest(ratio=comp$ratios1vs2)
```
while 
```{r}
robinAUC(graph=graph, model1=comp$Mean1, model2=comp$Mean2, measure="vi")
```
calculates the area under the two curves.
